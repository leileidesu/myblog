<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>链表 on 做我的小猫猫吧</title><link>https://leileidesu.github.io/myblog/tags/%E9%93%BE%E8%A1%A8/</link><description>Recent content in 链表 on 做我的小猫猫吧</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 29 Jun 2022 21:32:17 +0800</lastBuildDate><atom:link href="https://leileidesu.github.io/myblog/tags/%E9%93%BE%E8%A1%A8/index.xml" rel="self" type="application/rss+xml"/><item><title>Week1</title><link>https://leileidesu.github.io/myblog/leetcode/week1/</link><pubDate>Wed, 29 Jun 2022 21:32:17 +0800</pubDate><guid>https://leileidesu.github.io/myblog/leetcode/week1/</guid><description>今天开始做力扣的Hot100题单，即便是简答题也给我难哭了（笑，所以说，我真的需要这门文凭吗。
1 两数之和 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
你可以按任意顺序返回答案。
我第一眼只能想到先排个序然后双指针，我是笨蛋.jpg，不过我记得这个可以O(n)的。
其实要用哈希表，比如target是6，第一个数是2，看到2就往map里面加一个键值对(2,indexof(2))，等到下次遇到4的时候，在map里面找有没有2，有的话输出4的下标和indexof(2)就可以。
class Solution { public: vector&amp;lt;int&amp;gt; twoSum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { map&amp;lt;int, int&amp;gt; map1;//建立一个map int n=nums.size(); for(int i=0;i&amp;lt;n;i++) { if(map1.find(target - nums[i])!=map1.end())//是否遍历过target-num[i] { return {i,map1.find(target - nums[i])-&amp;gt;second}; } map1[nums[i]]=i;//nums[i]是第i个 } return {}; } }; 来个经典的
map&amp;lt;int, int&amp;gt; map1; 定义map。
if(map1.find(target - nums[i])!=map1.end()) 判断map里有没有元素用的。
map1[nums[i]]=i; 增加键值对的方式。
2 两数相加 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。
请你将两个数相加，并以相同形式返回一个表示和的链表。</description></item></channel></rss>